from __future__ import annotations

import json
import re
import base58

from logged_groups import logged_group
from typing import Union, Optional, Any
from .utils import get_from_dict

from ..environment import LOG_SENDING_SOLANA_TRANSACTION, EVM_LOADER_ID


class SolTxError(Exception):
    def __init__(self, receipt: dict):
        self.result = receipt

        log_list = SolReceiptParser(receipt).get_log_list()
        self.error = '. '.join([log for log in log_list if self._is_program_log(log)])
        if not len(self.error):
            self.error = json.dumps(receipt)

        super().__init__(self.error)

    @staticmethod
    def _is_program_log(log):
        PROGRAM_LOG = 'Program log: '
        TOTAL_MEMORY = 'Program log: Total memory occupied: '
        return log.startswith(PROGRAM_LOG) and (not log.startswith(TOTAL_MEMORY))


@logged_group("neon.Proxy")
class SolReceiptParser:
    PROGRAM_FAILED_TO_COMPLETE = 'ProgramFailedToComplete'
    COMPUTATION_BUDGET_EXCEEDED = 'ComputationalBudgetExceeded'
    READ_ONLY_BLOCKED = "trying to execute transaction on ro locked account"
    READ_WRITE_BLOCKED = "trying to execute transaction on rw locked account"
    BLOCKHASH_NOTFOUND = 'BlockhashNotFound'
    NUMSLOTS_BEHIND = 'numSlotsBehind'

    NONCE_RE = re.compile('Program log: [a-z/.]+:\d+ : Invalid Ethereum transaction nonce: acc (\d+), trx (\d+)')

    def __init__(self, receipt: Union[dict, Exception, str]):
        if isinstance(receipt, SolTxError):
            self._receipt = receipt.result
        else:
            self._receipt = receipt
        self._log_list = []
        self._is_log_list_init = False
        self._error: Union[str, list, None] = None
        self._is_error_init = False

    @staticmethod
    def raise_budget_exceeded():
        raise SolTxError({
            'err': {
                'InstructionError': [1, SolReceiptParser.COMPUTATION_BUDGET_EXCEEDED]
            }
        })

    def _get_value(self, *path) -> Any:
        return get_from_dict(self._receipt, *path)

    def _get_error(self) -> Union[str, list, None]:
        if isinstance(self._receipt, Exception):
            return str(self._receipt)

        err_from_receipt = self._get_value('result', 'meta', 'err', 'InstructionError')
        if err_from_receipt is not None:
            return err_from_receipt

        err_from_receipt_result = self._get_value('meta', 'err', 'InstructionError')
        if err_from_receipt_result is not None:
            return err_from_receipt_result

        err_from_send_trx_error = self._get_value('data', 'err', 'InstructionError')
        if err_from_send_trx_error is not None:
            return err_from_send_trx_error

        err_from_send_trx_error = self._get_value('data', 'err')
        if err_from_send_trx_error is not None:
            return err_from_send_trx_error

        err_from_prepared_receipt = self._get_value('err', 'InstructionError')
        if err_from_prepared_receipt is not None:
            return err_from_prepared_receipt

        return None

    def get_error(self) -> Union[str, list, None]:
        if not self._is_error_init:
            self._is_error_init = True
            self._error = self._get_error()
        return self._error

    def _get_log_list(self) -> [str]:
        if isinstance(self._receipt, Exception):
            return []
        if self._receipt is None:
            return []

        log_from_receipt = self._get_value('result', 'meta', 'logMessages')
        if log_from_receipt is not None:
            return log_from_receipt

        log_from_receipt_result = self._get_value('meta', 'logMessages')
        if log_from_receipt_result is not None:
            return log_from_receipt_result

        log_from_receipt_result_meta = self._get_value('logMessages')
        if log_from_receipt_result_meta is not None:
            return log_from_receipt_result_meta

        log_from_send_trx_error = self._get_value('data', 'logs')
        if log_from_send_trx_error is not None:
            return log_from_send_trx_error

        log_from_prepared_receipt = self._get_value('logs')
        if log_from_prepared_receipt is not None:
            return log_from_prepared_receipt

        return []

    def get_log_list(self):
        if not self._is_log_list_init:
            self._is_log_list_init = True
            self._log_list = self._get_log_list()
        return self._log_list

    def check_if_error(self) -> bool:
        return self.get_error() is not None

    def check_if_big_transaction(self) -> bool:
        """This exception is generated by solana python library"""
        if isinstance(self._receipt, Exception):
            return str(self._receipt).startswith("transaction too large:")
        return False

    def check_if_budget_exceeded(self) -> bool:
        """Error can be received as receipt or can be result of throwing an Exception"""
        error_type = self.get_error()
        if isinstance(error_type, list):
            error_type = error_type[1]

        if isinstance(error_type, str):
            return error_type in (self.PROGRAM_FAILED_TO_COMPLETE, self.COMPUTATION_BUDGET_EXCEEDED)
        return False

    def check_if_accounts_blocked(self) -> bool:
        log_list = self.get_log_list()
        if not len(log_list):
            self.error(f"Can't get logs from receipt: {json.dumps(self._receipt, sort_keys=True)}")
            return False

        for log in log_list:
            if (log.find(self.READ_ONLY_BLOCKED) >= 0) or (log.find(self.READ_WRITE_BLOCKED) >= 0):
                return True
        return False

    def check_if_blockhash_notfound(self) -> bool:
        return self.get_error() == self.BLOCKHASH_NOTFOUND

    def get_slots_behind(self) -> Optional[int]:
        if not self._receipt:
            return None
        return self._get_value('data', self.NUMSLOTS_BEHIND)

    def get_nonce_error(self) -> Optional[(int, int)]:
        log_list = self._get_log_list()
        for log in log_list:
            s = self.NONCE_RE.search(log)
            if s is not None:
                return s.groups()
        return None

@logged_group("neon.Proxy")
class Measurements:
    def __init__(self):
        pass

    # Do not change headers in info logs! This name used in CI measurements (see function `cleanup_docker` in
    # .buildkite/steps/deploy-test.sh)
    def extract(self, reason: str, receipt: {}):
        if not LOG_SENDING_SOLANA_TRANSACTION:
            return

        try:
            self.debug(f"send multiple transactions for reason {reason}")

            measurements = self._extract_measurements_from_receipt(receipt)
            for m in measurements:
                self.info(f'get_measurements: {json.dumps(m)}')
        except Exception as err:
            self.error(f"get_measurements: can't get measurements {err}")
            self.info(f"get measurements: failed result {json.dumps(receipt, indent=3)}")

    def _extract_measurements_from_receipt(self, receipt):
        if SolReceiptParser(receipt).check_if_error():
            self.warning("Can't get measurements from receipt with error")
            self.info(f"Failed result: {json.dumps(receipt, indent=3)}")
            return []

        log_messages = receipt['meta']['logMessages']
        transaction = receipt['transaction']
        accounts = transaction['message']['accountKeys']
        instructions = []
        for instr in transaction['message']['instructions']:
            instructions.append({
                'accs': [accounts[acc] for acc in instr['accounts']],
                'program': accounts[instr['programIdIndex']],
                'data': base58.b58decode(instr['data']).hex()
            })

        pattern = re.compile('Program ([0-9A-Za-z]+) (.*)')
        messages = []
        for log in log_messages:
            res = pattern.match(log)
            if res:
                (program, reason) = res.groups()
                if reason == 'invoke [1]':
                    messages.append({'program': program, 'logs': []})
            messages[-1]['logs'].append(log)

        for instr in instructions:
            if instr['program'] in ('KeccakSecp256k11111111111111111111111111111',):
                continue
            if messages[0]['program'] != instr['program']:
                raise ValueError('Invalid program in log messages: expect %s, actual %s' % (
                    messages[0]['program'], instr['program']))
            instr['logs'] = messages.pop(0)['logs']
            exit_result = re.match(r'Program %s (success)' % instr['program'], instr['logs'][-1])
            if not exit_result:
                raise ValueError("Can't get exit result")
            instr['result'] = exit_result.group(1)

            if instr['program'] == EVM_LOADER_ID:
                memory_result = re.match(r'Program log: Total memory occupied: ([0-9]+)', instr['logs'][-3])
                instruction_result = re.match(
                    r'Program %s consumed ([0-9]+) of ([0-9]+) compute units' % instr['program'], instr['logs'][-2])
                if not (memory_result and instruction_result):
                    raise ValueError("Can't parse measurements for evm_loader")
                instr['measurements'] = {
                    'instructions': instruction_result.group(1),
                    'memory': memory_result.group(1)
                }

        result = []
        for instr in instructions:
            if instr['program'] == EVM_LOADER_ID:
                result.append({
                    'program': instr['program'],
                    'measurements': instr['measurements'],
                    'result': instr['result'],
                    'data': instr['data']
                })
        return result
